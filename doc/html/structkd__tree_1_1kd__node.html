<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Kche-tree: kd_tree&lt; T, D, S &gt;::kd_tree::kd_node Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="classkd__tree.html">kd_tree</a>::<a class="el" href="structkd__tree_1_1kd__node.html">kd_node</a>
  </div>
</div>
<div class="contents">
<h1>kd_tree&lt; T, D, S &gt;::kd_tree::kd_node Struct Reference</h1><!-- doxytag: class="kd_tree::kd_node" -->Kd-tree branch node.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="kd-tree_8h-source.html">kd-tree.h</a>&gt;</code>
<p>

<p>
<a href="structkd__tree_1_1kd__node-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkd__tree_1_1kd__node_1_1kd__axis__comparer.html">kd_axis_comparer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Per axis element comparison functor. Used to apply STL sorting algorithms to individual axes.  <a href="structkd__tree_1_1kd__node_1_1kd__axis__comparer.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkd__tree_1_1kd__node.html#8fad3d670a0f399b41bbb4f902d91894">kd_node</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#8fad3d670a0f399b41bbb4f902d91894"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkd__tree_1_1kd__node.html#d978e8f5d39c9c3a75a2a19fd04a71a1">kd_node</a> (std::istream &amp;input)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct from an input stream.  <a href="#d978e8f5d39c9c3a75a2a19fd04a71a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkd__tree_1_1kd__node.html#8814547972c18ff5391c88f6f470466c">~kd_node</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default destructor.  <a href="#8814547972c18ff5391c88f6f470466c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkd__tree_1_1kd__node.html#c049999a6f6a1999d629c5dd1a3e8a2c">split</a> (unsigned int *index, unsigned int n, const <a class="el" href="structkd__tree_1_1kd__node_1_1kd__axis__comparer.html">kd_axis_comparer</a> &amp;comparer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a pivot to split the space in two by a chosen dimension during training.  <a href="#c049999a6f6a1999d629c5dd1a3e8a2c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structkd__tree_1_1kd__node.html#5c324af30f7f4b93f1579417baa5d412">explore</a> (const <a class="el" href="structkd__tree_1_1kd__node.html">kd_node</a> *parent, <a class="el" href="structkd__tree_1_1kd__search__data.html">kd_search_data</a> &amp;<a class="el" href="classkd__tree.html#13bb048566fd405d8dbfab17b8d9d7f6">data</a>, C &amp;candidates) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traverse the kd-tree looking for nearest neighbours candidates based on Manhattan distances.  <a href="#5c324af30f7f4b93f1579417baa5d412"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structkd__tree_1_1kd__node.html#36e2e00576932ec6893744b54a6af4e6">intersect</a> (const <a class="el" href="structkd__tree_1_1kd__node.html">kd_node</a> *parent, <a class="el" href="structkd__tree_1_1kd__search__data.html">kd_search_data</a> &amp;<a class="el" href="classkd__tree.html#13bb048566fd405d8dbfab17b8d9d7f6">data</a>, C &amp;candidates) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traverse the kd-tree checking hypersphere-hyperrectangle intersections to discard regions of the space.  <a href="#36e2e00576932ec6893744b54a6af4e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkd__tree_1_1kd__node.html#a65019b07c10b164230b40038231e54e">write_to_binary_stream</a> (std::ostream &amp;out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write to stream.  <a href="#a65019b07c10b164230b40038231e54e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="structkd__tree_1_1kd__node.html">kd_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkd__tree_1_1kd__node.html#0536a34c3726f799fe1860aaf3c105bd">build</a> (const <a class="el" href="structfeature__vector.html">kd_point</a> *<a class="el" href="classkd__tree.html#13bb048566fd405d8dbfab17b8d9d7f6">data</a>, unsigned int *index, unsigned int n, <a class="el" href="structkd__tree_1_1kd__node.html">kd_node</a> *parent, unsigned int bucket_size, unsigned int &amp;processed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build the kd-tree recursively.  <a href="#0536a34c3726f799fe1860aaf3c105bd"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap>union {</td></tr>

<tr><td class="memItemLeft" nowrap>&nbsp;&nbsp;&nbsp;<a class="el" href="structkd__tree_1_1kd__node.html">kd_node</a> *&nbsp;&nbsp;&nbsp;<a class="el" href="structkd__tree_1_1kd__node.html#4ff555178fcaa93df711b548ea2cecde">left_branch</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Left branch.  <a href="#b04d2b3c439ac554704516acac870888"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap>&nbsp;&nbsp;&nbsp;<a class="el" href="structkd__tree_1_1kd__leaf.html">kd_leaf</a> *&nbsp;&nbsp;&nbsp;<a class="el" href="structkd__tree_1_1kd__node.html#59534a578634d9543d88520c267b523c">left_leaf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Left leaf.  <a href="#9435c679c6db4e0200435400e26f1d1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap valign="top">};&nbsp;</td><td class="memItemRight" valign="bottom"></td></tr>

<tr><td class="memItemLeft" nowrap>union {</td></tr>

<tr><td class="memItemLeft" nowrap>&nbsp;&nbsp;&nbsp;<a class="el" href="structkd__tree_1_1kd__node.html">kd_node</a> *&nbsp;&nbsp;&nbsp;<a class="el" href="structkd__tree_1_1kd__node.html#87f203230c825da08e01114672915257">right_branch</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Right branch.  <a href="#829cfb68195807b80fc0e91694646f65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap>&nbsp;&nbsp;&nbsp;<a class="el" href="structkd__tree_1_1kd__leaf.html">kd_leaf</a> *&nbsp;&nbsp;&nbsp;<a class="el" href="structkd__tree_1_1kd__node.html#80edf9c918ac2b3dee8f71ab795cf076">right_leaf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Right leaf.  <a href="#40812a3447f6cc088c74f867e068d701"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap valign="top">};&nbsp;</td><td class="memItemRight" valign="bottom"></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkd__tree_1_1kd__node.html#42847d45ea98a18224105842a126f76f">split_value</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value used to split the hyperspace in two.  <a href="#42847d45ea98a18224105842a126f76f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap>union {</td></tr>

<tr><td class="memItemLeft" nowrap>&nbsp;&nbsp;&nbsp;unsigned int&nbsp;&nbsp;&nbsp;<a class="el" href="structkd__tree_1_1kd__node.html#eee0d52701e7b39d77871581d7237d55">axis</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index of the current axis being split.  <a href="#8c50b742f735f16ebdc06f0f3b2b0aec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap>&nbsp;&nbsp;&nbsp;unsigned int&nbsp;&nbsp;&nbsp;<a class="el" href="structkd__tree_1_1kd__node.html#c50d771ea96a5c9f046a08e24bd71a63">is_leaf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitmask used to check if left and right nodes are leafs or branches.  <a href="#bf2aef0d4546675e3e7d316da5a5ad53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap valign="top">};&nbsp;</td><td class="memItemRight" valign="bottom"></td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkd__tree_1_1kd__node.html#6332f352efe19e150dbf7ad7a9c8daf9">left_bit</a> = 0x80000000U</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask used to access the left branch bit in is_leaf.  <a href="#6332f352efe19e150dbf7ad7a9c8daf9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkd__tree_1_1kd__node.html#dcf2b60a3c5529882898dbde00e1e8e4">right_bit</a> = 0x40000000U</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask used to access the right branch bit in is_leaf.  <a href="#dcf2b60a3c5529882898dbde00e1e8e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkd__tree_1_1kd__node.html#1f0868798a3b49e7f6808df3d3a8128e">axis_mask</a> = 0x3FFFFFFFU</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask used to access the axis bits.  <a href="#1f0868798a3b49e7f6808df3d3a8128e"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T, const unsigned int D, typename S = k_vector&lt;vector_distance&lt;T&gt;, vector_distance&lt;T&gt; &gt;&gt;<br>
 struct kd_tree&lt; T, D, S &gt;::kd_node</h3>

Kd-tree branch node. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="8fad3d670a0f399b41bbb4f902d91894"></a><!-- doxytag: member="kd_tree::kd_node::kd_node" ref="8fad3d670a0f399b41bbb4f902d91894" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, const unsigned int D, typename S = k_vector&lt;vector_distance&lt;T&gt;, vector_distance&lt;T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::kd_tree::kd_node::kd_node           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="d978e8f5d39c9c3a75a2a19fd04a71a1"></a><!-- doxytag: member="kd_tree::kd_node::kd_node" ref="d978e8f5d39c9c3a75a2a19fd04a71a1" args="(std::istream &amp;input)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , const unsigned int D, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::kd_tree::kd_node::kd_node           </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct from an input stream. 
<p>
Build a kd-tree branch node from the data in a binary input stream. <dl class="warning" compact><dt><b>Warning:</b></dt><dd>A std::runtime_error exception may be thrown in case of error reading the data.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>in</em>&nbsp;</td><td>Input stream. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8814547972c18ff5391c88f6f470466c"></a><!-- doxytag: member="kd_tree::kd_node::~kd_node" ref="8814547972c18ff5391c88f6f470466c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , const unsigned int D, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::kd_tree::kd_node::~kd_node           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default destructor. 
<p>
Default node destructor. Delete the tree recursively handling branches and leaf nodes appropiately. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="0536a34c3726f799fe1860aaf3c105bd"></a><!-- doxytag: member="kd_tree::kd_node::build" ref="0536a34c3726f799fe1860aaf3c105bd" args="(const kd_point *data, unsigned int *index, unsigned int n, kd_node *parent, unsigned int bucket_size, unsigned int &amp;processed)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , const unsigned int D, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::<a class="el" href="structkd__tree_1_1kd__node.html">kd_node</a> * <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::kd_tree::kd_node::build           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfeature__vector.html">kd_point</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkd__tree_1_1kd__node.html">kd_node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>bucket_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>processed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build the kd-tree recursively. 
<p>
Build a kd-tree recursively.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Base of the data array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indices</em>&nbsp;</td><td>Array of indices to D-dimensional data vectors. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Number of elements in <em>index</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Parent node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bucket_size</em>&nbsp;</td><td>Number of elements that should be grouped in leaf nodes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>processed</em>&nbsp;</td><td>Number of elements already processed and stored in the tree. Updated as the building expands. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Node of the tree completely initialized. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5c324af30f7f4b93f1579417baa5d412"></a><!-- doxytag: member="kd_tree::kd_node::explore" ref="5c324af30f7f4b93f1579417baa5d412" args="(const kd_node *parent, kd_search_data &amp;data, C &amp;candidates) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , const unsigned int D, typename S &gt; </div>
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::kd_tree::kd_node::explore           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structkd__tree_1_1kd__node.html">kd_node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkd__tree_1_1kd__search__data.html">kd_search_data</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>search_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&nbsp;</td>
          <td class="paramname"> <em>candidates</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Traverse the kd-tree looking for nearest neighbours candidates based on Manhattan distances. 
<p>
Traverse the kd-tree looking for nearest neighbours candidates, but do not discard any regions of the space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Parent node of the one being explored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>search_data</em>&nbsp;</td><td>Auxiliar data structure used for tree traversal and incremental calculations. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>candidates</em>&nbsp;</td><td>STL container-like object holding the current neighbour candidates. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="36e2e00576932ec6893744b54a6af4e6"></a><!-- doxytag: member="kd_tree::kd_node::intersect" ref="36e2e00576932ec6893744b54a6af4e6" args="(const kd_node *parent, kd_search_data &amp;data, C &amp;candidates) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , const unsigned int D, typename S &gt; </div>
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::kd_tree::kd_node::intersect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structkd__tree_1_1kd__node.html">kd_node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkd__tree_1_1kd__search__data.html">kd_search_data</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>search_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&nbsp;</td>
          <td class="paramname"> <em>candidates</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Traverse the kd-tree checking hypersphere-hyperrectangle intersections to discard regions of the space. 
<p>
Traverse the kd-tree while discarding regions of space with hypersphere-hyperrectangle intersections.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Parent node of the one being explored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>search_data</em>&nbsp;</td><td>Auxiliar data structure used for tree traversal and incremental calculations. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>candidates</em>&nbsp;</td><td>STL container-like object holding the current neighbour candidates. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c049999a6f6a1999d629c5dd1a3e8a2c"></a><!-- doxytag: member="kd_tree::kd_node::split" ref="c049999a6f6a1999d629c5dd1a3e8a2c" args="(unsigned int *index, unsigned int n, const kd_axis_comparer &amp;comparer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , const unsigned int D, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::kd_tree::kd_node::split           </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structkd__tree_1_1kd__node_1_1kd__axis__comparer.html">kd_axis_comparer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>comparer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find a pivot to split the space in two by a chosen dimension during training. 
<p>
Split the provided data subset by one dimension. Should be near to the median to get a balanced kd-tree. The dimension used to split the data is also decided by this method. Any index sorting or partitioning must be also performed here.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>indices</em>&nbsp;</td><td>Array of indices to elements of the current data subset. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Number of elements in <em>index</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comparer</em>&nbsp;</td><td>Functor object used to compare data elements. Can be used with STL comparison-based algorithms.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The index of the pivot element in the index array used to split the space. All data in the left half must be less than the value associated to this index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a65019b07c10b164230b40038231e54e"></a><!-- doxytag: member="kd_tree::kd_node::write_to_binary_stream" ref="a65019b07c10b164230b40038231e54e" args="(std::ostream &amp;out)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , const unsigned int D, typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::kd_tree::kd_node::write_to_binary_stream           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write to stream. 
<p>
Write a kd-tree branch node to a binary ouput stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>Output stream. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if successful, <code>false</code> in case of write error. </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="b1a624c7502c5c1008f89bd10c7bf89f"></a><!-- doxytag: member="kd_tree::kd_node::@1" ref="b1a624c7502c5c1008f89bd10c7bf89f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union { ... }           </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d9a2016ab1a950f29b99ca2a923b9801"></a><!-- doxytag: member="kd_tree::kd_node::@3" ref="d9a2016ab1a950f29b99ca2a923b9801" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union { ... }           </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0e82f25baf83c7fdf411891ffda1fd6d"></a><!-- doxytag: member="kd_tree::kd_node::@5" ref="0e82f25baf83c7fdf411891ffda1fd6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union { ... }           </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="eee0d52701e7b39d77871581d7237d55"></a><!-- doxytag: member="kd_tree::kd_node::axis" ref="eee0d52701e7b39d77871581d7237d55" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, const unsigned int D, typename S = k_vector&lt;vector_distance&lt;T&gt;, vector_distance&lt;T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::<a class="el" href="structkd__tree_1_1kd__node.html#eee0d52701e7b39d77871581d7237d55">kd_tree::kd_node::axis</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Index of the current axis being split. 
<p>

</div>
</div><p>
<a class="anchor" name="1f0868798a3b49e7f6808df3d3a8128e"></a><!-- doxytag: member="kd_tree::kd_node::axis_mask" ref="1f0868798a3b49e7f6808df3d3a8128e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, const unsigned int D, typename S = k_vector&lt;vector_distance&lt;T&gt;, vector_distance&lt;T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::<a class="el" href="structkd__tree_1_1kd__node.html#1f0868798a3b49e7f6808df3d3a8128e">kd_tree::kd_node::axis_mask</a> = 0x3FFFFFFFU<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask used to access the axis bits. 
<p>

</div>
</div><p>
<a class="anchor" name="c50d771ea96a5c9f046a08e24bd71a63"></a><!-- doxytag: member="kd_tree::kd_node::is_leaf" ref="c50d771ea96a5c9f046a08e24bd71a63" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, const unsigned int D, typename S = k_vector&lt;vector_distance&lt;T&gt;, vector_distance&lt;T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::<a class="el" href="structkd__tree_1_1kd__node.html#c50d771ea96a5c9f046a08e24bd71a63">kd_tree::kd_node::is_leaf</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitmask used to check if left and right nodes are leafs or branches. 
<p>

</div>
</div><p>
<a class="anchor" name="6332f352efe19e150dbf7ad7a9c8daf9"></a><!-- doxytag: member="kd_tree::kd_node::left_bit" ref="6332f352efe19e150dbf7ad7a9c8daf9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, const unsigned int D, typename S = k_vector&lt;vector_distance&lt;T&gt;, vector_distance&lt;T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::<a class="el" href="structkd__tree_1_1kd__node.html#6332f352efe19e150dbf7ad7a9c8daf9">kd_tree::kd_node::left_bit</a> = 0x80000000U<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask used to access the left branch bit in is_leaf. 
<p>

</div>
</div><p>
<a class="anchor" name="4ff555178fcaa93df711b548ea2cecde"></a><!-- doxytag: member="kd_tree::kd_node::left_branch" ref="4ff555178fcaa93df711b548ea2cecde" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, const unsigned int D, typename S = k_vector&lt;vector_distance&lt;T&gt;, vector_distance&lt;T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkd__tree_1_1kd__node.html">kd_node</a>* <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::<a class="el" href="structkd__tree_1_1kd__node.html#4ff555178fcaa93df711b548ea2cecde">kd_tree::kd_node::left_branch</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Left branch. 
<p>

</div>
</div><p>
<a class="anchor" name="59534a578634d9543d88520c267b523c"></a><!-- doxytag: member="kd_tree::kd_node::left_leaf" ref="59534a578634d9543d88520c267b523c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, const unsigned int D, typename S = k_vector&lt;vector_distance&lt;T&gt;, vector_distance&lt;T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkd__tree_1_1kd__leaf.html">kd_leaf</a>* <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::<a class="el" href="structkd__tree_1_1kd__node.html#59534a578634d9543d88520c267b523c">kd_tree::kd_node::left_leaf</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Left leaf. 
<p>

</div>
</div><p>
<a class="anchor" name="dcf2b60a3c5529882898dbde00e1e8e4"></a><!-- doxytag: member="kd_tree::kd_node::right_bit" ref="dcf2b60a3c5529882898dbde00e1e8e4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, const unsigned int D, typename S = k_vector&lt;vector_distance&lt;T&gt;, vector_distance&lt;T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::<a class="el" href="structkd__tree_1_1kd__node.html#dcf2b60a3c5529882898dbde00e1e8e4">kd_tree::kd_node::right_bit</a> = 0x40000000U<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask used to access the right branch bit in is_leaf. 
<p>

</div>
</div><p>
<a class="anchor" name="87f203230c825da08e01114672915257"></a><!-- doxytag: member="kd_tree::kd_node::right_branch" ref="87f203230c825da08e01114672915257" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, const unsigned int D, typename S = k_vector&lt;vector_distance&lt;T&gt;, vector_distance&lt;T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkd__tree_1_1kd__node.html">kd_node</a>* <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::<a class="el" href="structkd__tree_1_1kd__node.html#87f203230c825da08e01114672915257">kd_tree::kd_node::right_branch</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Right branch. 
<p>

</div>
</div><p>
<a class="anchor" name="80edf9c918ac2b3dee8f71ab795cf076"></a><!-- doxytag: member="kd_tree::kd_node::right_leaf" ref="80edf9c918ac2b3dee8f71ab795cf076" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, const unsigned int D, typename S = k_vector&lt;vector_distance&lt;T&gt;, vector_distance&lt;T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkd__tree_1_1kd__leaf.html">kd_leaf</a>* <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::<a class="el" href="structkd__tree_1_1kd__node.html#80edf9c918ac2b3dee8f71ab795cf076">kd_tree::kd_node::right_leaf</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Right leaf. 
<p>

</div>
</div><p>
<a class="anchor" name="42847d45ea98a18224105842a126f76f"></a><!-- doxytag: member="kd_tree::kd_node::split_value" ref="42847d45ea98a18224105842a126f76f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, const unsigned int D, typename S = k_vector&lt;vector_distance&lt;T&gt;, vector_distance&lt;T&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classkd__tree.html">kd_tree</a>&lt; T, <a class="el" href="test__kdtree_8cpp.html#ab36b7f3966dcaeea1db0699a6054709">D</a>, S &gt;::<a class="el" href="structkd__tree_1_1kd__node.html#42847d45ea98a18224105842a126f76f">kd_tree::kd_node::split_value</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Value used to split the hyperspace in two. 
<p>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="kd-tree_8h-source.html">kd-tree.h</a><li><a class="el" href="kd-tree_8cpp.html">kd-tree.cpp</a><li><a class="el" href="kd-tree__io_8cpp.html">kd-tree_io.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Jun 26 13:09:26 2010 for Kche-tree by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
